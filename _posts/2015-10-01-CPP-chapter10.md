---
layout: post
title:  "C++ Primer Plus Chapter 10"
date:   2015-10-01
categories: C++
---

## Chapter 10 类和对象

- 抽象：将问题的本质特征抽象出来，根据特征来描述解决方案

- 指定基本类型：
    - 决定数据对象需要的内存数量
    - 决定如何解释内存中的位数
    - 决定可使用数据对象执行的操作或方法
    
 - ** 类**是一种将抽象转换为用户类型的C++工具。
 
     类定义：
     - 类声明：数据成员描述数据部分，成员函数描述公有接口
     - 类方法：如何实现类成员函数
     
 - 通常，接口（类定义）放在头文件中，将实现（类方法代码）放在源代码中
 
 - **类名首字母大写**
 
 - 对象/实例：声明类类型的具体变量
 
 - **公有成员函数**是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口
 
 - 类的默认访问类型为private
 
 - 定义成员函数时，用作用域解析运算符（::）来标识函数所属类；类方法可以访问类private组件
 
 - 内敛函数的特殊规则：每个使用的文件中都要对其进行定义，保证内联定义对多文件程序中的其他文件都可用。**可通过将内联定义放在定义类的头文件中**
 
 - 创建的新对象都有独立的存储空间，存储其内部变量和类成员；但是同一个类下的所有对象只共享同一组类方法
 
        Stock kate；
        Stock joe;
        
    kate.shares占一个内存块，joe.shares占据另一个内存块。kate.show()和joe.show()都调用同一个方法（函数）
    
### 构造函数和析构函数

#### 构造函数

- 构造函数没有声明类型，即没有返回类型

- 构造函数的参数表示的不是类成员，而是赋给类成员的值。因此，参数名不能与类成员相同

        Stock::Stock( const string &company, long shares, double share_val)
        { ... }
        
      改为：
        
        Stock::Stock( const string &company, long sm double d)
        
- **为了避免以上混乱，一种是在数据成员名中使用m_前缀，m_company；另一种是成员名售后后缀_，company_

- 初始化对象：
      - 显示 
      
            Stock food=Stock("N" ,250,1.5)
            
      - 隐式
      
            Stock garment("M", 50, 2.5)
            
- 为类定义了构造函数后，就必须为其提供默认构造函数。**定义默认构造函数方式：**
    - 给已有构造函数的所有参数提供默认值：
    
        Stock( const string &co="Error", int n=0, double pr=0.0);
        
   - **（常用）**函数重载，一个没有参数的构造函数：
   
        Stock::Stock()
        {
                company="no";
                shares=0;
                share_val=0.0;
        }
        
- **默认构造函数**可以没有任何参数；如果有，必须给所有参数都提供默认值

#### 析构函数

析构函数的类名前加~，即~Stock()，析构函数没有参数

- 默认情况下，将一个对象赋给同类型的另一个对象时， C++将源对象的每个数据成员的内容赋值到目标对象中相应的数据成员中

- 将新值赋给对象，stock1=Stock( "Nifty", 10, 50)，让构造函数创建新的、临时对象，将其内容复制过去，随后调用析构，删除临时对象

- Stock stock2=Stock("Boffo", 2,10);

    Stock1=Stock("Nity",10.50); 
    
    第一条语句是初始化**（常用）**，创建有指定值对象；第二条是赋值，在赋值前创建临时对象
    
- const成员函数 void stock::show() const 保证类方法不修改调用对象

### this指针

如果一个类成员函数涉及两个对象，即调用它的对象以及其他对象，需要使用this指针

- Stock为类，则

    const Stock &topval(const Stock & s) const
    
    const Stock &s表示不修改显式表示的对象，最后const表示函数不修改隐式访问对象，前面的const表示返回类型不变
    
    调用为top=stock1.topval(stock2)
    
- this指针指向调用对象，引用整个调用对象，则使用表达式*this；函数括号后面使用const，则不能使用this修改对象的值

#### 对象数组

- 声明对象数组与声明标准类型数组相同：Stock mystuff[4];

- 类包含多个构造函数，对不同元素使用不同的构造函数

    Stock stocks[3]={ Stock("NanoSm",20), Stock(), Stock("Mono") };
    
- 创建类对象数组，这个类必须要有默认构造数组。在初始化时，首先使用默认构造函数创建数组


### 类作用域

- 类中定义的名称（数据成员和成员函数）作用域为整个类

#### 定义常量，作用域为整个类
    
private: const int M=12; 不行，声明只描述了对象形式，没有创建对象

- **类中声明一个枚举**，用枚举为整型常量提供作用域为整个类的符号名称，其不创建类数据成员，只是一个符号名称

    private: enum { M=12 };
    
- **关键字static**，该常量将与其他静态变量存储在一起，不存储在对象中。即一个M常量，被所有对象分享

### 抽象数据类型

抽象数据类型（abstract data type, ADT）以通用的方式描述数据类型，没有引入语言或实现细节

